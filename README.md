**# Breakage**

**THIS VERSION IS IN A PRE-ALPHA STATE AND IS ONLY MEANT FOR DEMONSTRATIVE PURPOSES OF VARIOUS TECHNOLOGIES AND IDEAS. IT DOES NOT INCLUDE ANY ASSETS OR ACTUAL WAY TO IMPORT. NOT MEANT TO FORK OR FURTHER DEVELOPMENT. The actual Breakage game will be vastly different than what is in this repo.**

Breakage is a turn-based game with units that autofight. The player will Spawn units/towers/POIs from a pool of "cards in hand" obtained from various means. After spawning, you can then optionally assign various tasks to the units. To win the game, you need to defend your "Castle" from invading forces of various waves of monsters by improving your army while also trying to discover the misteries of the map itself and gain it's advantages. The game will feature unique gameplay mechanics that are not available in this version. 

**Scripts**
This project contains several scripts that manage the game logic and functionality. They are organized into different folders according to their purpose and functionality. Here is a brief overview of each folder and script:

The "Helpers" and "Scriptable Objects" folder contain scripts that are used by other scripts in the project. They implement common design patterns and functionalities that are useful for game development. They are:

**Singletons.cs**: This script implements the singleton design pattern in 3 levels of functionality (StaticInstance if we only want static info in the inherited script; Singleton that inherits StaticInstance with the addition of making sure that only one instance of this script is running, and a PersistentSingleton if you want it to live through Scene changes) and also provides a global access point to that instance. This script is inherited by other classes that need to be singletons, such as managers or controllers. The script has a private constructor and a static property representing the instance of the class. It also uses lazy initialization to create the instance only when needed.
Scriptable Objects: The scripts inside implement the object pooling design pattern, which reduces the performance overhead of instantiating and destroying game objects frequently. It creates a pool of reusable objects and enables or disables them as needed. This script is used by other classes that need to spawn or despawn objects, such as unit spawning. The script has a public method to get an object from the pool and a private method to return an object to the pool. It also uses a dictionary to store the pools of different types of objects.

The _Scripts folder also contains scripts that are specific to the game logic and functionality. They are:

**GameStateManager.cs**: This script controls the game state and transitions between different states. It uses the State interface and the StatePattern class to implement the state pattern design. The script has a public property to get and set the current state and a private method to change the state. It also has a reference to the UIManager.cs and the DatabaseManager.cs scripts to update the user interface and the database according to the game state. The script defines four states: MenuState, BattleState, VictoryState, and GameOverState. Each state implements the State interface and has a Enter, Update, and Exit method to define the behavior of the state. The script also uses the UnityEngine.Events namespace to create and invoke events when the state changes. Note: Given the Pre-Alpha state, it is still in a testing phase and some of the methods within the states may be questionable. If you want to use it, please adjust the methods according to actual design patterns and not testing procedures. 
**UIManager.cs**: This script manages the user interface, such as the menu, the battle screen, and the victory screen. It uses the UnityEngine.UI namespace to create and manipulate UI elements. The script has references to the UI elements, such as the score text, the health bar, and the game over panel. It also has a reference to the GameStateManager.cs script to get the current game state and display the appropriate UI. The script has public methods to update the UI elements, such as the score, the health, and the level. It also has private methods to enable or disable the UI elements, such as the menu, the battle screen, and the victory screen. The script also uses the UnityEngine.Events namespace to subscribe and unsubscribe to the events from the GameStateManager.cs script.
**ImputManager.cs**: Gets relevant input from player and sends it further to listening scripts. It also manages the camera lock and position for various click inputs.
**DatabaseManager.cs**: This script manages the database, which stores the game data, such as the units, the levels, and the scores. It uses the SQLite library to create and access a local database file. The script has a private method to create the database and the tables if they do not exist. It also has public methods to get and set the game data from and to the database, such as the units, the levels, and the scores. It also has a reference to the GameStateManager.cs script to get and set the game data according to the game state. The script also uses the System.Data and the Mono.Data.Sqlite namespaces to create and manipulate data structures, such as data tables and data readers.
**UnitManager.cs**: This script manages the units, which are the game characters that autofight. The script has references to the unit prefabs, which are game objects that have the Unit component attached. It also has references to the unit lists, which are collections of units that belong to the player or the enemy. It also has a reference to the DatabaseManager.cs script to get and set the unit data from and to the database. The script uses scriptable objects to store the unit attributes and behaviors, such as health, damage, and speed. The script also uses the singleton pattern to ensure that there is only one instance of the unit manager in the scene. The script has a public method to create and initialize the units from the prefabs and the scriptable objects. It also has private methods to update and destroy the units. The script implements a simple unit AI using finite state machines, which define the logic and actions of the units based on their states, goals, and conditions. The script defines three states: IdleState, AttackState, PatrolState and DieState. Each state implements the IUnitState interface and has a Enter, Update, and Exit method to define the behavior of the state. Finally we have conditional behaviour scripts that get auto-attached in unity whenever you get an object from pooling for ease of access to future developers and game designers. 
**UnitAI.cs** and dependant scripts: Employes various NavMesh tactics to allow Units to auto-pathfind, aquire targets and fight to their death, while using Database info on their stats and unique abbilities. 
